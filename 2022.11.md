#### 11.4

##### numpy 数组的拼接，合并

###### 水平组合

```python
numpy.hstack((a,b))
```

###### 垂直组合

```
numpy.vstack((a,b))
```

#### 11.14

##### c# string.concat([array)

合并数组元素

```c#
            public void testconcat()
            {
                 object[] strarr=new object[5];
                for (int i=0;i<5;i++)
                {
                    strarr[i] = i.ToString() + "";
                }
                string str = string.Concat(strarr);
                Console.WriteLine(str);
                Console.ReadLine();
            }
```

##### c# hashset 无序不重复集合

插入元素的操作非常快，不需要像List类那样重排集合。

HashSet类提供的方法可以创建合集和交集。

###### 并集

```c#
HashSet<int> numbers1;
HashSet<int> numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.UnionWith(numbers2);//求两个集合的并集。
```

###### 交集

```c#
HashSet<int> numbers1;
HashSet<int> numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.IntersectWith(numbers2);//求两个集合的交集。
```

###### 差集

```c#
HashSet<int> numbers1;
HashSet<int> numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.ExceptWith(numbers2);//求两个集合的差集。
```

###### 对称差集

```c#
HashSet<int> numbers1;
HashSet<int> numbers2;
//分别进行numbers1和numbers2的值初始化或赋值
numbers1.SymmetricExceptWith(numbers2);//求两个集合的对称差集。
```

##### c++ 获取 map 中value最大值/最小值对应的键值对

```c++
#include "GeomBasic.h"
#include "NscLinearity.h"
#include<iostream>
#include <algorithm>
#include <vector>
#include <map>

using namespace std;
/// <summary>
/// 比较函数
/// </summary>
/// <param name="left"></param>
/// <param name="right"></param>
/// <returns></returns>
bool cmp_value(const pair<double, double>left, const pair<double, double> right)
{
	return left.second < right.second;
}
/// <summary>
/// 拟合直线并判断数据拟合误差
/// </summary>
/// <param name="ptr"></param>
/// <param name="line"></param>
/// <returns></returns>
bool fit_line(vector<pair<double, double>> ptr, double* res)
{
	vector<double> x = vector<double>(ptr.size());
	vector<double> y = vector<double>(ptr.size());
	vector<double> dis = vector<double>(ptr.size());
	double stdev;
	double mean;
	int outsize = 0;
	for (int i = 0; i < ptr.size(); i++)
	{
		x[i] = ptr[i].first;
		y[i] = ptr[i].second;
	}
	// 拟合直线
	if (VMFitLine(x.data(), y.data(), ptr.size(),res))
	{
		for (int i = 0; i < ptr.size(); i++)
		{
			//计算拟合误差
			dis.push_back(DisPointToLineCoeff(res, x[i], y[i]));
		}
		//计算标准差
		num_stdev(dis.data(), dis.size(), stdev, mean);
		for (auto x:dis)
		{
			// 根据正太分布3-sigma法则 判断拟合误差分布情况
			if (x<(mean-3*stdev)||x>(mean+3*stdev))
			{
				outsize++;
			}
		}
		if ((dis.size()-outsize)/dis.size()<0.95)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	return false;
}
/// <summary>
/// 计算nsc线性区域
/// </summary>
/// <param name="nsc_value"></param>
/// <param name="z_value"></param>
/// <param name="array_size"></param>
/// <param name="z_max"></param>
/// <param name="z_min"></param>
/// <param name="z_mid"></param>
/// <returns></returns>
DLLOUTAPI bool __stdcall GetAfZRange(double* nsc_value, double* z_value, int array_size, double* z_max, double* z_min, double* z_mid,double* k, double* b)
{
	map<double, double> z_nsc;
	vector<pair<double, double>> line;
	//初始化
	for (int i = 0; i < array_size; i++)
	{
		z_nsc.emplace(z_value[i], nsc_value[i]);
	}
	//计算 根据value大小返回极值对应的key
	auto max = max_element(z_nsc.begin(), z_nsc.end(), cmp_value);
	auto min = min_element(z_nsc.begin(), z_nsc.end(), cmp_value);
	*z_max = max->first;
	*z_min = min->first;
	*z_mid = (*z_max + *z_min) / 2;
	// 提取线性区域数组范围
	for (int i = 0; i < array_size; i++)
	{
		if (z_value[i] >= *z_min && z_value[i] <= *z_max)
		{
			pair<double, double> temp(z_value[i], nsc_value[i]);
			line.push_back(temp);
		}
	}
	double res[2];
	// 拟合直线计算拟合误差
	if (fit_line(line, res))
	{
		*k = res[0];
		*b = res[1];
		return true;
	}
	else //如果拟合误差不满足3-sigma准则则返回false 
	{
		return false;
	}
	return false;
}
```

##### c++ 基本数据类型

布尔型 bool

字符型 char

整型 int

浮点型 float

双浮点型 double

无类型 void

宽字符型 wchar_t

##### static_cast 显式类型转换

1.用于基本数据类型的转换，及指针之间的转换

2.类层次中基类与子类成员函数指针的转换

3.类层次中基类与子类指针或引用之间的转换

static_cast常用来进行基本类型直接的转换，如char与int、int与float、enum与int之间；

static_cast也可以转换用户自定义类型，但目标类型必须含有相应的构造函数；

static_cast还可以转换对象的指针类型，但它不进行运行时类型检查，所以是不安全的；

static_cast甚至可以把任何表达式都转换成void类型；

satic_cast不能移除变量的const属性，请参考const_cast操作符；

static_cast进行的是简单粗暴的转换，所以其正确性完全由程序员自己保证。

##### C++拟合直线与求拟合误差实验

设计思路
一个平面点由两个坐标(x,y)确定，请编写一个表示平面点的类Point。要求：
在默认构造函数中初始化类对象为原点（0，0）；
添加一个带参数的构造函数，传入两个坐标值。
添加拷贝构造函数。
添加赋值操作函数operator=。
为类的两个成员添加getter函数和setter函数，getter函数为const函数；
平面直线的方程为ax+by+c=0 ，请设计一个类Line，表示一条平面直线。要求：
在默认构造函数中初始化直线为x轴。
添加一个带参数的构造函数，传入直线方程的三个系数。
添加拷贝构造函数。
添加赋值操作函数operator=。
添加一个函数，获取直线的方向 。
添加一个函数，获取该直线的三个参数。
添加一个函数，计算点到直线的距离，函数的参数是第一题的Point类对象。
添加一个函数，判断一个点是否在这条直线上，函数的参数是第一题的Point类对象。提示：由于存在计算误差，当点到直线的距离小于一个很小的阈值时，可以认为点在直线上。
编写一个函数，用于生成一组随机点Pi=xi,yi,i=1…m ，这些随机点都是某一条直线l:ax+by+c=0上 的点，但是受到很小的噪声污染，即， ,其中ηi 是一个很小的噪声，服从0均值高斯分布（使用std::normal_distrubtion生成满足高斯分布的随机数来模拟这个噪声。函数的输入为一个Line对象，样本点数目，输出为随机点数组。提示：使用vector<Point>传回生成的随机点对象数组。
编写一个函数FitLine，该函数传入一组随机点，返回一条直线。该直线是采用最小二乘法，用传入的随机点拟合的直线。
编写一个函数CalcDistance，计算一组点到一条直线的平均距离。
在main函数中，生成一个Line对象L0，并调用上述函数生成随机点集，然后调用你的FitLine函数拟合出直线L1。并用CalcDistance函数计算你所得到的直线L1与样本点集之间的拟合误差（即平均距离）。在main函数中，输出真实直线L0的方程，拟合直线L1的方程，以及拟合误差。

源码：

```c++
//Main.cpp
#include "leastSquare.h"
#include <iostream>
#include<ctime>
#include<random>
using namespace std;
using namespace leastSquare;
using namespace PointAndLine;
int main(int argc, char* argv[])
{
	srand(time(0));
	
	float ran1 = 0 + 1.0 * (rand() % RAND_MAX) / RAND_MAX * (1 - 0);
	float ran2 = 0 + 1.0 * (rand() % RAND_MAX) / RAND_MAX * (1 - 0);
	float ran3 = 0 + 1.0 * (rand() % RAND_MAX) / RAND_MAX * (1 - 0);
	
	PointAndLine::Line L0(ran1,ran2,ran3), L1;
	
	vector<Point> ptr = GenRanPoint(L0, 100);
	L1 = FitLine(ptr);
	float dis = CalcDistance(ptr, L1);
 
	float a, b, c;
	L1.getter(a, b, c);
	cout << "拟合直线方程为:" << endl;
	cout << a << "x + " << b << "y + " << c <<" = 0" << endl;
	cout << "拟合误差为:" << endl;
	cout << dis << endl;
	return 0;
```

```c++
//leastSquare.h
#ifndef _LEASQU_H_
#define _LEASQU_H_
#include<iostream>
#include <vector>
#include"PointAndLine.h"
using namespace PointAndLine;
using namespace std;
namespace leastSquare
{
	vector<Point> GenRanPoint(Line l, int num);
	Line FitLine(vector<Point> ptr);
	float CalcDistance(vector<Point> ptr, Line l);
}
#endif
```

```c++
//leastSquare.cpp
#include"leastSquare.h"
#include<cmath>
using namespace leastSquare;
float gaussrand()
{
	static float V1, V2, S;
	static int phase = 0;
	float X;
 
	if (phase == 0) {
		do {
			float U1 = (float)rand() / RAND_MAX;
			float U2 = (float)rand() / RAND_MAX;
 
			V1 = 2 * U1 - 1;
			V2 = 2 * U2 - 1;
			S = V1 * V1 + V2 * V2;
		} while (S >= 1 || S == 0);
 
		X = V1 * sqrt(-2 * log(S) / S);
	}
	else
		X = V2 * sqrt(-2 * log(S) / S);
 
	phase = 1 - phase;
 
	return X;
}
vector<Point> leastSquare::GenRanPoint(Line l, int num)
{
	float a, b, c;
	l.getter(a, b, c);
	float theta = gaussrand();
	vector<Point> p;
	for(int x = 1;x<num+1;x++)
	{
		x = static_cast<float>(x);
		float y = static_cast<float>((-a / b) * x - (c / b) + theta);
		Point index(x, y);
		p.push_back(index);
	}
	return p;
}
Line leastSquare::FitLine(vector<Point> ptr)
{
	float x = 0, y = 0, A = 0, B = 0, beta = 0;
	for(unsigned int i=0;i<ptr.size();i++)
	{
		x += ptr[i].getter_x();
		y += ptr[i].getter_y();
	}
	x = x / ptr.size();
	y = y / ptr.size();
	for (unsigned int i = 0; i < ptr.size(); i++)
	{
		A += pow(x - ptr[i].getter_x(), 2);
		B += (y - ptr[i].getter_y())*(x - ptr[i].getter_x());
	}
	beta = static_cast<float>(sqrt(pow(A, 2) + pow(B, 2)));
	const float a =static_cast<float>( -B / beta);
	const float b = static_cast<float>(A / beta);
	const float c = -a * x - b * y;
	Line line(a,b,c);
	return line;
}
float leastSquare::CalcDistance(vector<Point> ptr, Line l)
{
	float distance  = 0;
	for(int i = 0;i < ptr.size();i++)
	{
		distance += l.calcDistance(ptr[i]);
	}
	distance = distance / ptr.size();
	return distance;
}
```

```c++
// PointAndLine.h
#ifndef __PAL_CPP_
#define _PAL_CPP_
#include <cstdlib>
#include <cstddef>
namespace PointAndLine
{
	class Point
	{
	private:
		float x, y;
		friend class Line;
	public:
		Point() :x(0), y(0) {}
		Point(float _x, float _y);
		Point(const Point& p);
		Point& operator=(const Point& p);
		float getter_x()const;
		float getter_y()const;
		void setter(float _x, float _y);
	};
 
	class Line
	{
	private:
		float a, b, c;
	public:
		Line():a(0),b(1),c(0){}
		Line(float _a,float _b,float _c);
		Line(const Line& l);
		Line& operator=(const Line& l);
		void getter(float& _a, float& _b,float& _c)const;
		float calcDistance(Point p);
		bool point_In_line(Point p);
	};
}
#endif
```

```c++
//PointAndLine.cpp
#include"PointAndLine.h"
#include<iostream>
#include<cmath>
using namespace std;
using namespace PointAndLine;
Point::Point(float _x,float _y)
{
	this->x = _x;
	this->y = _y;
}
Point::Point(const Point &p)
{
	x = p.x;
	y = p.y;
}
Point& Point::operator=(const Point& p)
{
	if(this==NULL)
	{
		x = p.x;
		y = p.y;
	}
	return *this;
}
float Point::getter_x() const
{
	return x;
}
float Point::getter_y() const
{
	return y;
}
void Point::setter(float _x,float _y)
{
	x = _x;
	y = _y;
}
Line::Line(float _a, float _b, float _c)
{
	a = _a;
	b = _b;
	c = _c;
}
Line::Line(const Line& l)
{
	a = l.a;
	b = l.b;
	c = l.c;
}
Line& Line::operator=(const Line& l)
{
	if(this!=NULL)
	{
		a = l.a;
		b = l.b;
		c = l.c;
	}
	return *this;
}
void Line::getter(float& _a, float& _b, float& _c)const
{
	_a = this->a;
	_b = this->b;
	_c = this->c;
}
float Line::calcDistance(Point p)
{
	return static_cast<float>(abs(a * p.x + b * p.y + c) / sqrt(pow(p.x, 2)+pow(p.y, 2)));
}
bool Line::point_In_line(Point p)
{
	if(a*p.x+b*p.y+c<static_cast<float>(1e-1))
	{
		return true;
	}
	return false;
}

```

##### 网格提取 python

```python
import cv2
import numpy as np
import sys
import math
import Algo.Common.AlignmentAlgo as match
from Algo.Common.ImageBasicAlgo import *
from Tools.ImageWatch import *
import functools
from Tools.Logger import *


def rectdComp(rectd1, rectd2):
    thresh = rectd1[1][0] * 0.5
    dx = rectd1[0][0] - rectd2[0][0]
    if dx > thresh:
        return 1
    elif dx < -thresh:
        return -1
    else:
        dy = rectd1[0][1] - rectd2[0][1]
        if dy > thresh:
            return 1
        elif dy < -thresh:
            return -1
        else:
            return 0


class GridBlockFinder:
    log = None
    _minBlockArea = 9  # block的最小面积
    _minBlockCount = 3  # block的最小数量
    image = 0  # 输入图像
    image_width = 0  # 输入图像宽度
    image_height = 0  # 输入图像高度
    grid_dist = 0  # block间距
    half_grid_dist = 0  # block间距
    center_rect_index = 0  # 中心block的索引
    search_radius = 10  # 匹配的搜索范围
    block_size = 0  # 图像中block的尺寸,像素级精度
    pattern = 0  # 匹配坐标的模板图像
    blockIndex_by_row = 0  # 每行block的个数
    blockIndex_by_col = 0  # 每列block的个数

    def __init__(self, log_value, image, pixel_size, block_pattern_period, is_dark_block=True, pattern=None):
        """
        输入待检测图像, 提取所有block
        :param image: 输入图像
        :param is_DarkBlock: block是否是黑色的,默认黑色
        """
        # 如果是三通道图像,那么转换为灰度图
        self.log = log_value
        gray_image = image
        shape = image.shape
        if len(shape) == 3:
            gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

        # 如果是黑色block,那么将颜色翻转
        if is_dark_block:
            gray_image = 255 - gray_image

        self.image = gray_image
        self.image_width = shape[1]
        self.image_height = shape[0]
        self.grid_dist = block_pattern_period / pixel_size
        self.half_grid_dist = self.grid_dist * 0.5

        self.centerRowBlocks = []  # 中间一行block对象
        # self.centerColBlocks = []  # 中间一列block对象
        # self.centerRowBlocksPos = []  # 中间一行block对象的精确坐标
        # self.centerColBlocksPos = []  # 中间一列block对象的精确坐标
        self.allBlocksByRow = []  # 所有block对象按行排列
        self.allBlocksByCol = []  # 所有block对象按列排列
        self.allBlocksPosSortByRow = []  # 所有block对象的精确坐标按行排列
        self.allBlocksPosSortByCol = []  # 所有block对象的精确坐标按列排列
        self.row_vec = []  # block延伸方向 行向量
        self.col_vec = []  # block延伸方向 列向量
        self.all_blocks = []  # 所有的block
        # self.extractBlocksPosSortByRow = []   #根据范围提取的block对象的精确坐标按行排列
        # self.extractBlocksPosSortByCol = []   #根据范围提取的block对象的精确坐标按列排列
        # 查找block
        if self.__findAllRectds():
            # self.showAllRects("raw block")

            self.all_blocks = self.__removeEdgeRectd(self.all_blocks, self.grid_dist * 0.5)
            self.__showAllRects("remove edge block")

            self.all_blocks.sort(key=functools.cmp_to_key(rectdComp))

            image_center = [self.image_width * 0.5, self.image_height * 0.5]
            self.center_rect_index, dist = self.__findNearestRectd(image_center, self.all_blocks)

            # index, dist = self.findNearestRectd(self.all_blocks[self.center_rect_index][0], self.all_blocks[1:])
            # dx = self.all_blocks[0][0][0] - self.all_blocks[1][0][0]
            # dy = self.all_blocks[0][0][1] - self.all_blocks[1][0][1]
            # self.grid_dist = np.sqrt(dx * dx + dy * dy)
            # self.half_grid_dist = self.grid_dist * 0.5

            seed_rect = self.all_blocks[self.center_rect_index]
            self.block_size = int((seed_rect[1][0] + seed_rect[1][1]) * 0.5)
            self.__calBlockVector(seed_rect)
            if pattern is None:
                self.__updatePattern()
            else:
                self.pattern = pattern
            self.blockIndex_by_row = len(self.GetAllBlocksByRow())
            self.blockIndex_by_col = len(self.GetAllBlocksByCol())

        else:
            self.all_blocks = []
        return

    def __updatePattern(self):
        """
        更新匹配坐标的模板图像
        """
        bbx = self.__calRectRoi(self.all_blocks[0])
        self.pattern = CropImg(self.image, bbx)
        self.log.NoteImage(self.pattern, "pattern")

    def __showAllRects(self, title=""):
        count = len(self.all_blocks)
        positionX = []
        positionY = []
        for i in range(count):
            positionX.append(self.all_blocks[i][0][0])
            positionY.append(self.all_blocks[i][0][1])
        plt.scatter(positionX, positionY, color='#88c999')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.title(title)
        plt.savefig(self.log.GetImageFullPath(title))
        # plt.show()
        plt.clf()

    def __findNearestRectd(self, point, rectds):
        """
        插值距离point最近的rect
        :param point: 输入点
        :param rectds: 所有输入矩形
        :return:
        """
        index = 0
        min_dist = sys.float_info.max

        for i in range(len(rectds)):
            dx = abs(point[0] - rectds[i][0][0])
            dy = abs(point[1] - rectds[i][0][1])
            dist = dx + dy
            if dist < min_dist:
                min_dist = dist
                index = i
        dx = abs(point[0] - rectds[index][0][0])
        dy = abs(point[1] - rectds[index][0][1])
        min_dist = np.sqrt(dx * dx + dy * dy)
        return index, min_dist

    def __findNearestRectdBinary(self, point, rectds, gridDist):
        """
        插值距离point最近的rect
        :param point: 输入点
        :param rectds: 所有输入矩形,要求中心坐标以x从小到大排序,y从小到大排序
        :param half_grid_dist: 距离判断阈值
        :return:
        """
        # 查找起始
        dist = sys.float_info.max
        start = 0
        end = len(rectds)
        index = 0
        halfGridDist = gridDist * 0.5
        while start <= end:
            if end - start == 1:  # 存在缺失的block
                break
            index = int((start + end) / 2)
            dx = point[0] - rectds[index][0][0]
            if dx > halfGridDist:
                start = index
            elif dx < (-halfGridDist):
                end = index
            else:
                dy = point[1] - rectds[index][0][1]
                if dy > halfGridDist:
                    start = index
                elif dy < (-halfGridDist):
                    end = index
                else:
                    dist = np.sqrt(dx * dx + dy * dy)
                    break

        return index, dist

    def __calBlockVector(self, block):
        """
        计算block的方向
        :param block: 输入block
        :return:
        """
        start_angle = block[2]
        if start_angle < -45:
            start_angle = start_angle + 90
        if start_angle > 45:
            start_angle = start_angle - 90

        angle = start_angle * np.pi / 180
        self.row_vec = [np.cos(angle), np.sin(angle)]
        self.col_vec = [-np.sin(angle), np.cos(angle)]
        return

    def __removeEdgeRectd(self, blocks, edgeMargin):
        """
        去除靠近边界的block
        :param blocks: 输入block
        :param edgeMargin: 边界阈值
        :return:
        """
        count = len(blocks)
        print()
        index = count - 1
        while index >= 0:
            x, y = blocks[index][0]
            isEdgeRect = (x <= edgeMargin) | (y <= edgeMargin) | (x >= (self.image_width - edgeMargin)) | (
                    y >= (self.image_height - edgeMargin))
            if isEdgeRect:
                del self.all_blocks[index]
            index = index - 1
        return blocks

    def __findAllRectds(self):
        """
        查找所有rectds
        :return: 成功返回True,失败返回False
        """
        image_blur = cv2.medianBlur(self.image, 3)  # 中值滤波去除噪点
        # 二值化
        # retval, binary_image = cv2.threshold(image_blur, 127, 255, cv2.THRESH_OTSU)
        binary_image = cv2.adaptiveThreshold(image_blur, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 303, 0)
        # pltShow1(binary_image)
        # 根据二值图找轮廓
        contours, hierarchy = cv2.findContours(binary_image, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
        if len(contours) < self._minBlockCount:
            return False

        rect_areas = []
        # 获取所有矩形block
        for contour in contours:
            # 获取最小包围矩形
            rect = cv2.minAreaRect(contour)
            width, height = rect[1]
            rectArea = width * height
            if rectArea < 9:
                continue
            # # 是否是边缘矩形
            # isEdgeRect = (x < width) | (y < height) | (x > (self.image_width - width)) | (
            #         y > (self.image_height - height))
            # if isEdgeRect:
            #     continue
            conArea = cv2.contourArea(contour)
            if conArea < self._minBlockArea:  # 去除面积过小的矩形
                continue
            is_rect = conArea / rectArea  # 判断矩形度
            # 判断是否是正方形
            is_block = abs(width - height) / max(width, height)
            if (is_rect > 0.7) & (is_block < 0.3):
                is_align = False  # 添加是否align 标记位
                rect = list([list(rect[0]), list(rect[1]), rect[2], is_align])
                self.all_blocks.append(rect)
                rect_areas.append(conArea)
        if len(self.all_blocks) < self._minBlockCount:  # 判断格子梳理是否过少
            return False

        # 去除面积异常block
        mean_area = np.mean(rect_areas)
        stdev_area = np.std(rect_areas, ddof=1)
        thresh = 3 * stdev_area
        count = len(self.all_blocks)
        index = count - 1
        while index >= 0:
            if np.abs(rect_areas[index] - mean_area) > thresh:
                del self.all_blocks[index]
            index = index - 1
        return True

    def __showInvalidBlock(self, rectd):
        roiBbx = self.__calRectRoi(rectd)
        roi = CropImg(self.image, roiBbx)
        cv2.imwrite(self.log.GetImageFullPath("invalidBlock"), roi)
        # plt.figure(figsize=(12, 6))
        # ax1 = plt.subplot(1, 1, 1)
        # ax1.imshow(roi, cmap='gray')
        # plt.savefig(self.log.GetImageFullPath("invalidBlock"))
        # # plt.show()
        # plt.clf()

    def __getOneColRects(self, seedRectd):
        """
        获取当前rect对应的一列block
        :param seedRectd:种子block
        :return:
        """
        oneCol = [seedRectd]
        seedIndex, min_dist = self.__findNearestRectdBinary(seedRectd[0], self.all_blocks, self.grid_dist)
        thresh = self.grid_dist * 0.5

        seedX, seedY = seedRectd[0]
        nextPos = [seedX + self.col_vec[0] * self.grid_dist, seedY + self.col_vec[1] * self.grid_dist]
        while (nextPos[1] < self.image_height - self.half_grid_dist) & (nextPos[0] > self.half_grid_dist) & (
                nextPos[0] < self.image_width - self.half_grid_dist):
            next_index, min_dist = self.__findNearestRectdBinary(nextPos, self.all_blocks,
                                                                 self.grid_dist)
            if min_dist < thresh:
                oneCol.append(self.all_blocks[next_index])
                nextPos[0] = self.all_blocks[next_index][0][0] + self.col_vec[0] * self.grid_dist
                nextPos[1] = self.all_blocks[next_index][0][1] + self.col_vec[1] * self.grid_dist
            else:
                rectd = [[nextPos[0], nextPos[1]], oneCol[0][1], oneCol[0][2], False]
                oneCol.append(rectd)
                # self.__showInvalidBlock(rectd)
                nextPos[0] = nextPos[0] + self.col_vec[0] * self.grid_dist
                nextPos[1] = nextPos[1] + self.col_vec[1] * self.grid_dist

        nextPos[0] = seedX - self.col_vec[0] * self.grid_dist
        nextPos[1] = seedY - self.col_vec[1] * self.grid_dist
        while (nextPos[1] > self.half_grid_dist) & (nextPos[0] > self.half_grid_dist) & (
                nextPos[0] < self.image_width - self.half_grid_dist):
            next_index, min_dist = self.__findNearestRectdBinary(nextPos, self.all_blocks[0:seedIndex],
                                                                 self.grid_dist)
            if min_dist < thresh:
                oneCol.append(self.all_blocks[next_index], )
                nextPos[0] = self.all_blocks[next_index][0][0] - self.col_vec[0] * self.grid_dist
                nextPos[1] = self.all_blocks[next_index][0][1] - self.col_vec[1] * self.grid_dist
            else:
                rectd = [[nextPos[0], nextPos[1]], oneCol[0][1], oneCol[0][2], False]
                oneCol.append(rectd)
                # self.__showInvalidBlock(rectd)
                nextPos[0] = nextPos[0] - self.col_vec[0] * self.grid_dist
                nextPos[1] = nextPos[1] - self.col_vec[1] * self.grid_dist

        oneCol.sort(key=lambda i: i[0][1])

        return oneCol

    def __getOneRowRects(self, seedRectd):
        """
        获取当前rect对应的一行block
        :param seedRectd: 种子block
        :return:
        """
        oneRow = [seedRectd]
        seedIndex, min_dist = self.__findNearestRectdBinary(seedRectd[0], self.all_blocks, self.grid_dist)

        thresh = self.grid_dist * 0.25
        seedX, seedY = seedRectd[0]
        nextPos = [seedX + self.row_vec[0] * self.grid_dist, seedY + self.row_vec[1] * self.grid_dist]
        while (nextPos[0] < self.image_width - self.half_grid_dist) & (nextPos[1] > self.half_grid_dist) & (
                nextPos[1] < self.image_height - self.half_grid_dist):
            next_index, min_dist = self.__findNearestRectdBinary(nextPos, self.all_blocks,
                                                                 self.grid_dist)
            if min_dist < thresh:
                oneRow.append(self.all_blocks[next_index])
                nextPos[0] = self.all_blocks[next_index][0][0] + self.row_vec[0] * self.grid_dist
                nextPos[1] = self.all_blocks[next_index][0][1] + self.row_vec[1] * self.grid_dist
            else:
                rectd = [[nextPos[0], nextPos[1]], oneRow[0][1], oneRow[0][2], False]
                oneRow.append(rectd)
                # self.__showInvalidBlock(rectd)

                nextPos[0] = nextPos[0] + self.row_vec[0] * self.grid_dist
                nextPos[1] = nextPos[1] + self.row_vec[1] * self.grid_dist

        nextPos[0] = seedX - self.row_vec[0] * self.grid_dist
        nextPos[1] = seedY - self.row_vec[1] * self.grid_dist
        while (nextPos[0] > self.half_grid_dist) & (nextPos[1] > self.half_grid_dist) & (
                nextPos[1] < self.image_height - self.half_grid_dist):
            next_index, min_dist = self.__findNearestRectdBinary(nextPos, self.all_blocks[:seedIndex],
                                                                 self.grid_dist)
            if min_dist < thresh:
                oneRow.append(self.all_blocks[next_index])
                nextPos[0] = self.all_blocks[next_index][0][0] - self.row_vec[0] * self.grid_dist
                nextPos[1] = self.all_blocks[next_index][0][1] - self.row_vec[1] * self.grid_dist
            else:
                rectd = [[nextPos[0], nextPos[1]], oneRow[0][1], oneRow[0][2], False]
                oneRow.append(rectd)
                # self.__showInvalidBlock(rectd)
                nextPos[0] = nextPos[0] - self.row_vec[0] * self.grid_dist
                nextPos[1] = nextPos[1] - self.row_vec[1] * self.grid_dist

        oneRow.sort(key=lambda i: i[0][0])

        return oneRow

    # def getImg(self, image, bbx):
    #     """
    #     从当前图像截取图像
    #     :param image: 输入图像
    #     :param bbx: roi区域[y,x,height,width]
    #     :return: roi图像
    #     """
    #     return image[bbx[0]:(bbx[0] + bbx[2]), bbx[1]:(bbx[1] + bbx[3])]

    def __calRectRoi(self, rectd):
        """
        获取rotateRect的外扩矩形ROI
        :param rectd: 输入rotateRect
        :return: roi[y,x,height,width]
        """
        x = int(rectd[0][0] - self.grid_dist / 2)
        y = int(rectd[0][1] - self.grid_dist / 2)
        width = int(self.grid_dist)
        height = int(self.grid_dist)
        bbx = [y, x, height, width]

        return bbx

    def __getBlocksPosition(self, rectds, index, mode=0):
        """
        获取block的位置
        :param rectds: 计算block的亚像素图像坐标
        :return: block的亚像素图像坐标[x,y]
        """

        positions = []
        for i in range(len(rectds)):
            if rectds[i][3]:  # 如果align标志位为true 说明已经align 直接返回坐标
                positions.append(rectds[i][0])
            else:
                roiBbx = self.__calRectRoi(rectds[i])
                roi = CropImg(self.image, roiBbx)
                offsety, offsetx, sft_img = match.subpixelAlignment(roi, self.pattern, self.search_radius)
                x = roiBbx[1] + roiBbx[3] * 0.5 + offsetx
                y = roiBbx[0] + roiBbx[2] * 0.5 + offsety
                if mode == 0:
                    self.allBlocksByCol[index][i][0] = [x, y]
                    self.allBlocksByCol[index][i][3] = True
                if mode == 1:
                    self.allBlocksByCol[i][index][0] = [x, y]
                    self.allBlocksByCol[i][index][3] = True
                positions.append([x, y])
        return positions

    def __getCenterRowBlocks(self):
        """
        获取 图像中心一行block对应的cv2.RotateRect
        :return: 图像中心一行block对应的cv2.RotateRect
        """
        if len(self.centerRowBlocks) > 0:
            return self.centerRowBlocks

        if len(self.all_blocks) > 0:
            self.centerRowBlocks = self.__getOneRowRects(self.all_blocks[self.center_rect_index])

        return self.centerRowBlocks

    '''外部使用'''

    # def GetCenterColBlocks(self):
    #     """
    #     获取 图像中心一列block对应的cv2.RotateRect
    #     :return: 图像中心一列block对应的cv2.RotateRect
    #     """
    #     if len(self.centerColBlocks) > 0:
    #         return self.centerColBlocks
    #
    #     if len(self.all_blocks) > 0:
    #         self.centerColBlocks = self.getOneColRects(self.all_blocks[self.center_rect_index])
    #
    #     return self.centerColBlocks

    # def GetCenterRowBlocksPos(self):
    #     """
    #     获取图像中心处一行block中心的亚像素坐标
    #     :return: 图像中心处一行block中心的亚像素坐标
    #     """
    #     if len(self.centerRowBlocksPos) > 0:
    #         return self.centerRowBlocksPos
    #
    #     if len(self.all_blocks) > 0:
    #         rectds = self.getCenterRowBlocks()
    #         self.centerRowBlocksPos = self.getBlocksPosition(rectds, 2)
    #
    #     return self.centerRowBlocksPos
    #
    # def GetCenterColBlocksPos(self):
    #     """
    #     获取图像中心处一列block中心的亚像素坐标
    #     :return: 图像中心处一列block中心的亚像素坐标
    #     """
    #     if len(self.centerColBlocksPos) > 0:
    #         return self.centerColBlocksPos
    #
    #     if len(self.all_blocks) > 0:
    #         rectds = self.GetCenterColBlocks()
    #         self.centerColBlocksPos = self.getBlocksPosition(rectds, 3)
    #
    #     return self.centerColBlocksPos

    def GetAllBlocksByRow(self):
        """
        获取所有block(cv2.RotateRect),并按行排列
        :return: 所有block对应的cv2.RotateRect((中心)(长宽)(角度)),并按行排列
        """

        if len(self.allBlocksByRow) > 0:
            return self.allBlocksByRow
        if len(self.allBlocksByCol) > 0:
            self.allBlocksByRow = list(map(list, zip(*self.allBlocksByCol)))
            return self.allBlocksByRow
        else:
            temp = self.GetAllBlocksByCol()
            self.allBlocksByRow = list(map(list, zip(*temp)))

        return self.allBlocksByRow

    def GetAllBlocksByCol(self):
        """
        获取所有block(cv2.RotateRect),并按列排列
        :return: 所有block对应的cv2.RotateRect((中心)(长宽)(角度)),并按列排列
        """
        if len(self.allBlocksByCol) > 0:
            return self.allBlocksByCol
        if len(self.allBlocksByRow) > 0:
            self.allBlocksByCol = list(map(list, zip(*self.allBlocksByRow)))
            return self.allBlocksByCol
        if len(self.all_blocks) > 0:
            oneRowBlocks = self.__getCenterRowBlocks()
            for i in range(len(oneRowBlocks)):
                self.allBlocksByCol.append(self.__getOneColRects(oneRowBlocks[i]))
        return self.allBlocksByCol

    def GetAllBlocksPosSortByRow(self):
        """
        获取所有block中心的亚像素坐标,并按行排列
        :return: 按行排列的block中心的亚像素图像坐标[x,y]
        """
        if len(self.allBlocksPosSortByCol) > 0:  # 如果已经按列排列则转置返回
            self.allBlocksPosSortByRow = list(map(list, zip(*self.allBlocksPosSortByCol)))
            return self.allBlocksPosSortByRow
        else:
            temp = self.GetAllBlocksPosSortByCol()
            self.allBlocksPosSortByRow = list(map(list, zip(*temp)))
        return self.allBlocksPosSortByRow

    def GetAllBlocksPosSortByCol(self):
        """
        获取所有block中心的亚像素坐标,并按列排列
        :return: 按列排列的block中心的亚像素图像坐标[x,y]
        """
        if len(self.allBlocksPosSortByCol) > 0:
            return self.allBlocksPosSortByCol
        if len(self.allBlocksPosSortByRow) > 0:  # 如果已经按行排列则转置返回
            self.allBlocksPosSortByCol = list(map(list, zip(*self.allBlocksPosSortByRow)))
            return self.allBlocksPosSortByCol

        if len(self.all_blocks) > 0:
            if len(self.allBlocksByCol) == 0:
                self.allBlocksByCol = self.GetAllBlocksByCol()
            count = len(self.allBlocksByCol)
            for i in range(count):
                pos = self.__getBlocksPosition(self.allBlocksByCol[i], i)
                self.allBlocksPosSortByCol.append(pos)
        return self.allBlocksPosSortByCol

    def GetExtractBlockPosSortByRow(self, ranges: "提取行的范围"):
        """
        获取指定block中心的亚像素坐标,并按行排列
        :param: 提取列的范围，如果只提取一列则范围上下限相同，范围取bolockfinder.blockIndex_by_row
        :return: 按行排列的block中心的亚像素图像坐标[x,y]
        """
        extract_block_by_row = list()
        temp = list()
        extractBlocksPosSortByRow = list()
        if len(self.all_blocks) > 0:
            if len(self.allBlocksByCol) == 0:
                self.allBlocksByCol = self.GetAllBlocksByCol()
            for j in range(ranges[0], ranges[1] + 1):
                for i in range(len(self.allBlocksByCol)):
                    temp.append(self.allBlocksByCol[i][j])
                extract_block_by_row.append(temp)
        for x in range(len(extract_block_by_row)):
            pos = self.__getBlocksPosition(extract_block_by_row[x], x, 1)
            extractBlocksPosSortByRow.append(pos)
        return extractBlocksPosSortByRow

    def GetExtractBlockPosSortByCol(self, ranges: "提取列的范围"):
        """
        获取指定block中心的亚像素坐标,并按列排列
        :param: 提取列的范围，如果只提取一列则范围上下限相同，范围取bolockfinder.blockIndex_by_col
        :return: 按列排列的block中心的亚像素图像坐标[x,y]
        """
        extractBlocksPosSortByCol = list()
        if len(self.all_blocks) > 0:
            if len(self.allBlocksByCol) == 0:
                self.allBlocksByCol = self.GetAllBlocksByCol()
            for i in range(ranges[0], ranges[1] + 1):
                pos = self.__getBlocksPosition(self.allBlocksByCol[i], i)
                extractBlocksPosSortByCol.append(pos)
        return extractBlocksPosSortByCol


class SwathGridBlockFinder:
    def __init__(self, log_value: Logger, image_value, pixel_size_value, block_pattern_period_value
                 , is_vertical_image_value=True, split_size_value=300000):
        """
        :param: log_value: log对象  image_value :大图 pixel_size_value: 像素比
        block_pattern_period_value: 图像block间距  is_vertical_image_value: 是否是竖图
        split_size_value ：分割间距
        """
        self.image = image_value
        self.pixel_size = pixel_size_value
        self.block_pattern_period = block_pattern_period_value
        self.log = log_value
        self.is_vertical_image = is_vertical_image_value
        self.split_size = split_size_value
        self.image_list = self.__cut_big_image()
        self.blockfinder_list = self.__register_finder()
        self.blockIndex_by_col = self.__find_min_index()
        self.block_size = self.blockfinder_list[0].block_size
        self.grid_dist = self.blockfinder_list[0].grid_dist

    def __cut_big_image(self):
        """
        分割大图
        """
        image_list = list()
        if self.is_vertical_image:
            rows = self.image.shape[0]
            num_of_cut = int(rows / self.split_size)
            for i in range(num_of_cut):
                temp = self.image[self.split_size * i:self.split_size * (i + 1), :]
                image_list.append(temp)
        else:
            cols = self.image.shape[1]
            num_of_cut = int(cols / self.split_size)
            for i in range(num_of_cut):
                temp = self.image[:, self.split_size * i:self.split_size * (i + 1)]
                image_list.append(temp)
        return image_list

    def __find_min_index(self):
        """
        索引大图有多少列
        """
        min_index = sys.float_info.max
        for b in self.blockfinder_list:
            if b.blockIndex_by_col < min_index:
                min_index = b.blockIndex_by_col - 1
        return min_index

    def __register_finder(self):
        """
        注册每个子图的提取block对象
        """
        temp = list()
        for n in range(len(self.image_list)):
            one_finder = GridBlockFinder(self.log, self.image_list[n], self.pixel_size, self.block_pattern_period)
            temp.append(one_finder)
        return temp

    def __get_block_positions(self, blockfinder, col_index, refer_seed_x=False, seed_x=0.0):
        """
        提取坐标
        """
        if refer_seed_x:  # 根据输入的列的位置选择使用第几列
            all_blocks_by_col = blockfinder.GetAllBlocksByCol()
            dx = seed_x - all_blocks_by_col[col_index][0][0][0]
            col_index = col_index + round(dx / blockfinder.grid_dist)
        if col_index < self.blockIndex_by_col:   # 待提取列小于该图最多列数时才可执行
            position_col = blockfinder.GetExtractBlockPosSortByCol([col_index, col_index])  # 获取某一列的位置
            if position_col[0][0][0] - seed_x > 5 and refer_seed_x:   # 如果匹配极差大于5说明匹配错误，直接返回
                x_position, y_position = [0], [0]
                return list(x_position), list(y_position)
            x_position, y_position = zip(*position_col[0])
        else:
            x_position, y_position = [0], [0]
        return list(x_position), list(y_position)

    def swath_position_sort(self, col_range):
        """
        提取输入范围的block center position 按列排序
        :param:col_range:按列排序的范围col_range取self.blockIndex_by_col 如果取其中某一列则范围相等
        :return:图像block中心坐标按列排列
        """
        center_position_all = []
        x_position_all = []
        y_position_all = []
        for x in range(col_range[0], col_range[1] + 1):   # 遍历提取范围
            pattern = None
            before = 0  # 最后一个block距离图像末端的距离
            x_position_all.clear()
            y_position_all.clear()
            for i in range(len(self.image_list)):        # 遍历分割的元素
                split_length = 0
                blockfinder = self.blockfinder_list[i]
                grid_dist = blockfinder.grid_dist  # block周期长度
                if i > 0:                                # 从第二个元素开始需要计算偏移
                    blockfinder.pattern = pattern
                    x_position, y_position = self.__get_block_positions(blockfinder, x, True,
                                                                        x_position_all[len(x_position_all) - 1])
                    if len(x_position) == 1 or len(y_position) == 1:   # 如果提取不成功，则直接跳出
                        break
                    dy = before + y_position[0]
                    dx = x_position[0] - x_position_all[len(x_position_all) - 1]
                    length = math.sqrt(dx * dx + dy * dy)
                    before = self.image_list[i].shape[0] - y_position[len(y_position) - 1]
                    insert_count = int(length / grid_dist + 0.5) - 1
                    if insert_count > 0:
                        split_length = length / (insert_count + 1)
                        vx = dx / length
                        vy = dy / length
                        for j in range(insert_count):
                            x_position_all.append(x_position_all[len(x_position_all) - 1] + vx * split_length * (j + 1))
                            y_position_all.append(y_position_all[len(y_position_all) - 1] + vy * split_length * (j + 1))
                    y_shift = y_position_all[len(y_position_all) - 1] + split_length - y_position[0]
                    y_position = (np.mat(y_position) + y_shift).tolist()[0]
                else:
                    x_position, y_position = self.__get_block_positions(blockfinder, x)
                    before = self.image_list[i].shape[0] - y_position[len(y_position) - 1]
                    pattern = blockfinder.pattern

                x_position_all += x_position
                y_position_all += y_position
            self.log.Note('第'+str(x)+'列计算完成')
            one_col = list(map(list, zip(x_position_all, y_position_all)))
            center_position_all.append(one_col)
        return center_position_all

    def position_sort_by_col(self):
        """
        提取所有的block center position 按列排序
        :return:图像block中心坐标按列排列
        """
        ranges = [1, self.blockIndex_by_col - 1]    # 规定所有的范围
        col = self.swath_position_sort(ranges)      # 获取所有的坐标
        first_len = len(col[0])
        define_index = 0
        for u in range(len(col)):                   # 索引那一列block最少
            if len(col[u]) < first_len:
                define_index = u
                break
        if define_index > 0:                        # 如果存在某一列block缺失则返回每一列中元素最小的为基准
            res = list()
            for p in range(len(col)):
                temp = col[p][:len(col(define_index))]
                res.append(temp)
        res = col
        return res

    def position_sort_by_row(self):
        """
        提取所有的block center position 按行排序
        :return:图像block中心坐标按行排列
        """
        temp = self.position_sort_by_col()
        row = list(map(list, zip(*temp)))
        return row
```

##### alignment python

```python
import cv2
import numpy as np
import math
import scipy.ndimage
from numpy.fft import fft2, ifft2

"""
    Subpixel alignment routine
    src: uint8 image
    dst: uint8 image
    search_radius: maximum offset in integer pixels, 
                   search_radius=2 means that the offset cannot be larger than ±2 pixels
    compute_residual: boolean
                      return residual if true
"""


def subpixelAlignment(dst_img, src_img, search_radius=2):
    assert (dst_img.shape[0] == src_img.shape[0] and dst_img.shape[1] == src_img.shape[1])
    dst = dst_img.astype(np.float32) / 255.0
    src = src_img.astype(np.float32) / 255.0

    # L2 residual computation
    # res = computeL2DistanceNaive(dst, src, search_radius)
    res = computeL2DistanceFFT(dst, src, search_radius)

    # restrict to region with margin 1
    minIdx = np.argmin(res[1:2 * search_radius, 1:2 * search_radius]).astype(np.uint16)

    # get 2d indexes from flattened indexes
    ki, kj = np.unravel_index(minIdx, (2 * search_radius - 1, 2 * search_radius - 1))
    dist = res[ki:ki + 3, kj:kj + 3].flatten()
    spi, spj = subPixelMinimum(dist)
    offseti = ki + 1 - search_radius + spi
    offsetj = kj + 1 - search_radius + spj

    # shift ref_img using spline
    shifted = scipy.ndimage.shift(src, (offseti, offsetj), np.float32, order=3, mode='grid-wrap')
    sft_img = np.uint8(np.clip(shifted * 255.0 + 0.5, 0, 255))
    return offseti, offsetj, sft_img


def computeL2DistanceNaive(dst, src, extent=2):
    assert (dst.shape[0] == src.shape[0] and dst.shape[1] == src.shape[1])
    res = np.zeros((2 * extent + 1, 2 * extent + 1))
    dst_pad = np.pad(dst, extent, 'wrap')
    for i in range(2 * extent + 1):
        for j in range(2 * extent + 1):
            # Distance computation
            sum = 0
            for p in range(src.shape[0]):
                for q in range(src.shape[1]):
                    sum += (dst_pad[i + p, j + q] - src[p, q]) ** 2
            res[i][j] = sum
    return res


def computeL2DistanceFFT(dst, src, extent=2):
    assert (dst.shape[0] == src.shape[0] and dst.shape[1] == src.shape[1])
    ones = np.ones_like(src)
    T1 = np.sum(src ** 2)
    T2 = ifft2(fft2(dst ** 2) * fft2(ones).conj()).real
    T3 = ifft2(fft2(dst) * fft2(src).conj()).real
    T = T1 + T2 - 2 * T3
    T11 = T[-extent:, -extent:]
    T12 = T[-extent:, :extent + 1]
    T21 = T[:extent + 1, -extent:]
    T22 = T[:extent + 1, :extent + 1]
    return np.block([[T11, T12], [T21, T22]])


def subPixelMinimum(dist):
    # Six filters that are used to construct matrix A and vector b
    # A and b are parameters of the quadratic approximation
    fA11 = [0.250, -0.50, 0.250, 0.50, -1., 0.50, 0.250, -0.50, 0.250]
    fA22 = [0.250, 0.50, 0.250, -0.50, -1., -0.50, 0.250, 0.50, 0.250]
    fA12 = [0.250, 0.00, -0.250, 0.00, 0., 0.00, -0.250, 0.00, 0.250]
    fb1 = [-0.125, 0.00, 0.125, -0.25, 0., 0.25, -0.125, 0.00, 0.125]
    fb2 = [-0.125, -0.25, -0.125, 0.00, 0., 0.00, 0.125, 0.25, 0.125]

    # Construct A and b
    # by cross-correlating filters with the 3x3 neighborhoods
    A11, A12, A22, b1, b2 = 0, 0, 0, 0, 0
    for i in range(9):
        d = dist[i]
        A11 += fA11[i] * d
        A12 += fA12[i] * d
        A22 += fA22[i] * d
        b1 += fb1[i] * d
        b2 += fb2[i] * d

    # Make sure that A is positive semi-definite
    A11 = max(0, A11)
    A22 = max(0, A22)
    if A11 * A22 - A12 ** 2 < 0:
        # Put all off-diagonal values of A to zero
        A12 = 0

    # Compute the determinant of matrix A
    det = A11 * A22 - A12 ** 2

    # Return zero if singular
    if det == 0:
        resI = 0
        resJ = 0
    else:
        # Compute the offset vector
        # it is the minimum of the quadratic mu = - A^(-1) b
        osvI = -(A11 * b2 - A12 * b1) / det
        osvJ = -(A22 * b1 - A12 * b2) / det
        # Compute the norm of this vector
        nrm = math.sqrt(osvI ** 2 + osvJ ** 2)
        # Only keep it if it is less than one pixel away
        resI = osvI * (nrm < 1)
        resJ = osvJ * (nrm < 1)
    return resI, resJ


def template_match_cv(ref_img, template_img, score):
    image_gray = cv2.cvtColor(ref_img, cv2.COLOR_BGR2GRAY)
    template_gray = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)
    result = cv2.matchTemplate(image_gray, template_gray, cv2.TM_CCOEFF_NORMED)
    (minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(result)
    if maxVal < score:
        return
    (startX, startY) = maxLoc
    offset_x = startX + template_gray.shape[1] * 0.5 - image_gray.shape[1] * 0.5
    offset_y = startY + template_gray.shape[0] * 0.5 - image_gray.shape[0] * 0.5
    score = maxVal
    return offset_x, offset_y, score
```

#### 11.22

##### 代码记录 GeomBasic

```c++
#include "GeomBasic.h"
#include <numeric>

///vecY 的列数为1
bool LeastSquaresFit(cv::Mat vecX, cv::Mat vecY, double* param)
{
    cv::Mat vecT;
    transpose(vecX, vecT);
    cv::Mat A = vecT * vecX;
    cv::Mat b = vecT * vecY;
    cv::Mat x = A.inv() * b;

    for (int row = 0; row < vecX.cols; row++)
    {
        param[row] = *x.ptr<double>(row);
    }
    return true;
}

//最小二乘法拟合 x*a=y; a=inv(xT*x)*(xT*y)
DLLOUTAPI bool __stdcall LeastSquaresFit(int dataNum, int xDim, int ydim, double* x, double* y, double* res)
{
    int xsize[2] = { dataNum , xDim };
    int ysize[2] = { dataNum , ydim };
    cv::Mat xmat = cv::Mat(2, xsize, CV_64FC1, x);
    cv::Mat ymat = cv::Mat(2, ysize, CV_64FC1, y);

    cv::Mat xt = xmat.t();
    cv::Mat a = (xt * xmat).inv() * (xt * ymat);

    for (int row = 0; row < xDim; row++) {
        const double* ptr = a.ptr<double>(row);
        for (int col = 0; col < ydim; col++) {
            *res = *ptr;
            ++res;
            ++ptr;
        }
    }

    return 1;
}

#pragma region 直线

DLLOUTAPI bool __stdcall FitLineWaferPosition(WaferPosition* coordXY, int count, double* slope, double* zeroOffset, bool reverseDirection)
{
    vector<double> x = vector<double>(2 * count, 1);
    vector<double> y = vector<double>(count, 0);
    if (!reverseDirection)
    {
        for (int i = 0; i < count; ++i)
        {
            x[i * 2] = coordXY[i].x;
            y[i] = coordXY[i].y;
        }
    }
    else
    {
        for (int i = 0; i < count; ++i)
        {
            x[i * 2] = coordXY[i].y;
            y[i] = coordXY[i].x;
        }
    }

    vector<double> res = vector<double>(2, 0);
    LeastSquaresFit(count, 2, 1, x.data(), y.data(), res.data());
    *slope = res[0];
    *zeroOffset = res[1];

    return true;
}

DLLOUTAPI bool __stdcall VMFitLine(double* xIn, double* yIn, int count, double* param)
{
    if (count < 2)
    {
        return false;
    }
    cv::Mat vecX = cv::Mat::ones(count, 2, CV_64FC1);
    cv::Mat vecY(count, 1, CV_64FC1);

    for (int r = 0; r < count; r++)
    {
        vecY.at<double>(r, 0) = yIn[r];
        vecX.at<double>(r, 0) = xIn[r];
    }

    return LeastSquaresFit(vecX, vecY, param);
}
#pragma endregion

#pragma region 拟合圆
DLLOUTAPI ErrorType __stdcall VMFitCircle(double* xIn, double* yIn, int count, double* xCenter, double* yCenter, double* radius)
{
    if (count < 3) { return TZ_NG; }

    double X1 = 0;
    double Y1 = 0;
    double X2 = 0;
    double Y2 = 0;
    double X3 = 0;
    double Y3 = 0;
    double X1Y1 = 0;
    double X1Y2 = 0;
    double X2Y1 = 0;

    for (int i = 0; i < count; i++)
    {
        X1 = X1 + xIn[i];
        Y1 = Y1 + yIn[i];
        X2 = X2 + xIn[i] * xIn[i];
        Y2 = Y2 + yIn[i] * yIn[i];
        X3 = X3 + xIn[i] * xIn[i] * xIn[i];
        Y3 = Y3 + yIn[i] * yIn[i] * yIn[i];
        X1Y1 = X1Y1 + xIn[i] * yIn[i];
        X1Y2 = X1Y2 + xIn[i] * yIn[i] * yIn[i];
        X2Y1 = X2Y1 + xIn[i] * xIn[i] * yIn[i];
    }

    double C, D, E, G, H, N;
    double a, b, c;
    N = count;
    C = N * X2 - X1 * X1;
    D = N * X1Y1 - X1 * Y1;
    E = N * X3 + N * X1Y2 - (X2 + Y2) * X1;
    G = N * Y2 - Y1 * Y1;
    H = N * X2Y1 + N * Y3 - (X2 + Y2) * Y1;
    a = (H * D - E * G) / (C * G - D * D);
    b = (H * C - E * D) / (D * D - G * C);
    c = -(a * X1 + b * Y1 + X2 + Y2) / N;

    double A, B, R;
    A = a / (-2);
    B = b / (-2);
    R = sqrt(a * a + b * b - 4 * c) / 2;

    *xCenter = A;
    *yCenter = B;
    *radius = R;

    return TZ_OK;
}
#pragma endregion

#pragma region 曲线

DLLOUTAPI bool __stdcall  FitNDimcurve(std::vector<double> xIn, std::vector<double> yIn, int nDim, std::vector<double>& param)
{
    int dataNum = xIn.size();
    if (dataNum != yIn.size())
    {
        return false;
    }

    param = std::vector<double>(nDim + 1, 0);
    nDim = nDim + 1 <= xIn.size() ? nDim : xIn.size() - 1;
    if (nDim < 1)
    {
        return false;
    }

    cv::Mat vecX = cv::Mat::ones(dataNum, nDim + 1, CV_64FC1);
    cv::Mat vecY(dataNum, 1, CV_64FC1);

    for (int r = 0; r < dataNum; r++)
    {
        double* vecXptr = vecX.ptr<double>(r);
        for (int i = 1; i <= nDim; ++i)
        {
            *(vecXptr + i) = std::pow(xIn[r], i);
        }

        vecY.at<double>(r, 0) = yIn[r];
    }

    return LeastSquaresFit(vecX, vecY, param.data());
}

DLLOUTAPI bool __stdcall  CalNDimcurve(std::vector<double> xIn, std::vector<double> param, std::vector<double>& yIn)
{
    yIn.clear();
    if (xIn.size() > 0 && param.size() > 0)
    {
        yIn = std::vector<double>(xIn.size(), 0);
        for (int n = 0; n < xIn.size(); ++n)
        {
            for (int d = 0; d < param.size(); ++d)
            {
                yIn[n] += param[d] * std::pow(xIn[n], d);
            }
        }
    }

    return true;
}

DLLOUTAPI bool __stdcall  VMFitParabola(double* xIn, double* yIn, int count, double* param)
{
    if (count < 3)
    {
        return false;
    }

    cv::Mat vecX = cv::Mat::ones(count, 3, CV_64FC1);
    cv::Mat vecY(count, 1, CV_64FC1);

    for (int r = 0; r < count; r++)
    {
        vecY.at<double>(r, 0) = yIn[r];
        vecX.at<double>(r, 0) = xIn[r] * xIn[r];
        vecX.at<double>(r, 1) = xIn[r];
    }
    return LeastSquaresFit(vecX, vecY, param);
}

DLLOUTAPI bool __stdcall  VMFitCubic(double* xIn, double* yIn, int count, double* param)
{
    if (count < 4)
    {
        return false;
    }

    cv::Mat vecX = cv::Mat::ones(count, 4, CV_64FC1);
    cv::Mat vecY(count, 1, CV_64FC1);

    for (int r = 0; r < count; r++)
    {
        vecY.at<double>(r, 0) = yIn[r];
        vecX.at<double>(r, 0) = xIn[r] * xIn[r] * xIn[r];
        vecX.at<double>(r, 1) = xIn[r] * xIn[r];
        vecX.at<double>(r, 2) = xIn[r];
    }
    return LeastSquaresFit(vecX, vecY, param);
}


//抛物线拟合，复刻KT算法
DLLOUT double CurveFittingParabola(vector<double> dataX, vector<double> dataY, vector<double> sigma, vector<double>& coeff)
{
    if (dataX.size() < 3 || dataY.size() < 3 || coeff.size() < 3 || dataX.size() != dataY.size() || sigma.size() != dataY.size())
        return -1;//错误
    double average = 0.0;
    int size = dataY.size();
    for (int index1 = 0; index1 < size; index1++)
        average += dataX[index1];
    average /= size;
    for (int j = 0; j < size; j++)
        dataX[j] = dataX[j] - average;
    for (int i = 0; i < sigma.size(); i++) {
        if (fabs(sigma[i]) < 1E-5)
            return -1;// CMUtils.curveFittingParabola() sigma value is 0
    }
    double yxSum1 = 0.0;
    double yxSum2 = 0.0;
    double yxSum3 = 0.0;
    double xSum11 = 0.0;
    double xSum12 = 0.0;
    double xSum13 = 0.0;
    double xSum22 = 0.0;
    double xSum23 = 0.0;
    double xSum33 = 0.0;

    for (int k = 0; k < size; k++)
    {
        yxSum1 += dataY[k] * 1.0 / (sigma[k] * sigma[k]);
        yxSum2 += dataY[k] * dataX[k] / (sigma[k] * sigma[k]);
        yxSum3 += dataY[k] * dataX[k] * dataX[k] / (sigma[k] * sigma[k]);
        xSum11 += 1.0 / (sigma[k] * sigma[k]);
        xSum12 += dataX[k] / (sigma[k] * sigma[k]);
        xSum13 += dataX[k] * dataX[k] / (sigma[k] * sigma[k]);
        xSum22 += dataX[k] * dataX[k] / (sigma[k] * sigma[k]);
        xSum23 += dataX[k] * dataX[k] * dataX[k] / (sigma[k] * sigma[k]);
        xSum33 += dataX[k] * dataX[k] * dataX[k] * dataX[k] / (sigma[k] * sigma[k]);
    }

    cv::Mat mat1 = (cv::Mat_<double>(4, 4) <<
        yxSum1, yxSum2, yxSum3, 0.0,
        xSum12, xSum22, xSum23, 0.0,
        xSum13, xSum23, xSum33, 0.0,
        0, 0, 0, 1);
    cv::Mat mat2 = (cv::Mat_<double>(4, 4) <<
        xSum11, xSum12, xSum13, 0.0,
        yxSum1, yxSum2, yxSum3, 0.0,
        xSum13, xSum23, xSum33, 0.0,
        0, 0, 0, 1);
    cv::Mat mat3 = (cv::Mat_<double>(4, 4) <<
        xSum11, xSum12, xSum13, 0.0,
        xSum12, xSum22, xSum23, 0.0,
        yxSum1, yxSum2, yxSum3, 0.0,
        0, 0, 0, 1);
    cv::Mat denomMatrix = (cv::Mat_<double>(4, 4) <<
        xSum11, xSum12, xSum13, 0.0,
        xSum12, xSum22, xSum23, 0.0,
        xSum13, xSum23, xSum33, 0.0,
        0, 0, 0, 1);

    double det1 = cv::determinant(mat1);
    double det2 = cv::determinant(mat2);
    double det3 = cv::determinant(mat3);
    double denom = cv::determinant(denomMatrix);

    coeff[0] = det3 / denom;
    coeff[1] = det2 / denom;
    coeff[2] = det1 / denom;
    double chiSquare = 0.0;
    for (int m = 0; m < size; m++) {
        double temp = 1.0 / sigma[m] * (dataY[m] - coeff[0] * dataX[m] * dataX[m] + coeff[1] * dataX[m] + coeff[2]);
        chiSquare += temp * temp;
    }
    int degreesOfFreedom = dataY.size() - coeff.size();
    double reducedChiSquare = chiSquare / degreesOfFreedom;
    double a = coeff[0];
    double b = coeff[1];
    double c = coeff[2];
    coeff[1] = b - 2.0 * coeff[0] * average;
    coeff[2] = c - (coeff[1] + coeff[0] * average) * average;
    return reducedChiSquare;
}

DLLOUT double CurveFittingParabola(vector<double> dataX, vector<double> dataY, double sigma, vector<double>& coeff)
{
    int len = dataY.size();
    vector<double> sigmaArr(len);
    if (sigma < 0.0)
        return -1;//错误
    if (sigma == 0.0)
    {
        for (int i = 0; i < len; i++)
            sigmaArr[i] = 1.0;
    }
    else
    {
        for (int i = 0; i < len; i++)
            sigmaArr[i] = sigma;
    }
    double chiSquare = CurveFittingParabola(dataX, dataY, sigmaArr, coeff);
    return chiSquare;
}

DLLOUT vector<double> CurveFittingParabola(vector<double> dataX, vector<double> dataY, vector<double>& coeff)
{
    vector<double> xData = dataX;
    vector<double> data(dataY.size());
    vector<double> sortedX(xData.size());
    for (int i = xData.size() - 1; i >= 0; i--) {
        double max = -2.147483648E9;
        int maxIndex = INT_MIN;
        for (int j = 0; j < xData.size(); j++) {
            if (max < xData[j]) {
                max = xData[j];
                maxIndex = j;
            }
        }
        data[i] = dataY[maxIndex];
        sortedX[i] = xData[maxIndex];
        xData[maxIndex] = -2.147483648E9;
    }
    CurveFittingParabola(dataX, dataY, 0.0, coeff);
    return sortedX;
}

DLLOUT void CurveFittingParabola(vector<double> data, vector<double>& coeff)
{
    int len = data.size();
    vector<double> dataX(data.size());
    for (int i = 0; i < len; i++)
        dataX[i] = i;
    CurveFittingParabola(dataX, data, coeff);
}


#pragma endregion

//#pragma region 距离计算

DLLOUTAPI double DisPointToLineCoeff(double coeff[2], double x0, double y0)
{
    double dis = abs(coeff[0] * x0 - y0 + coeff[1]) / sqrt(1.0 + coeff[0] * coeff[0]);
    return dis;
}

//#pragma endregion

#pragma region 在图片中寻找匹配圆形
//DLLOUTAPI CircleFindResult __stdcall findCircle(TZImage img)
//{
//    cv::Mat imageInput = TZImage2Mat(img);
//    cv::Mat grayImage;
//    cv::cvtColor(imageInput, grayImage, cv::COLOR_BGR2GRAY);
//    CircleFindResult result;
//
//    // 检测圆形
//    vector<cv::Vec3f> circles;
//    double dp = 2;
//    double minDist = 10;
//    double param1 = 100;
//    double param2 = 100;
//    int min_radius = 20;
//    int max_radius = 600;
//    HoughCircles(grayImage, circles, cv::HOUGH_GRADIENT, dp, minDist, param1, param2, min_radius, max_radius);
//
//    // 绘制最大的圆形
//    cv::Vec3f biggestCircle = circles[0];
//
//    for (int i = 0; i < circles.size(); i++)
//    {
//        if (circles[i][2] > biggestCircle[2])
//        {
//            biggestCircle = circles[i];
//        }
//    }
//
//    result.center = ImagePosition(biggestCircle[0], biggestCircle[1]);
//    result.diameter = biggestCircle[2] * 2;
//
//    return result;
//}
#pragma endregion

//#pragma region 计算距离

double Dist2D(const TZPOINT& pointInA, const TZPOINT& pointInB)
{
    return sqrt((pointInA.x - pointInB.x) * (pointInA.x - pointInB.x) +
        (pointInA.y - pointInB.y) * (pointInA.y - pointInB.y));
}

//#pragma endregion

#pragma region 计算点

bool IsPointIn(const TZPOINT& point, const TZLINE& line)
{
    TZVector vTmpA = TZVector(line.point, point).Unit();
    TZVector vTmpB = line.vector;
    vTmpB = vTmpB.Unit();

    if (vTmpA.IsZero()) return true;
    if (vTmpB.IsZero())	return false;
    return fabs(fabs(TZVector::Vect_pointMult(vTmpA, vTmpB)) - 1) < 1E-8;
}

DLLOUTAPI int __stdcall  IntersectPointLineLine(const TZLINE& line1In, const TZLINE& line2In, TZPOINT& pointOut)
{
    double dC1 = -line1In.vector.j * line1In.point.x + line1In.vector.i * line1In.point.y;
    double dC2 = -line2In.vector.j * line2In.point.x + line2In.vector.i * line2In.point.y;

    double dC3 = -line1In.vector.j * line2In.vector.i + line1In.vector.i * line2In.vector.j;
    double dA3 = -line1In.vector.i * dC2 + dC1 * line2In.vector.i;
    double dB3 = dC1 * line2In.vector.j - line1In.vector.j * dC2;

    if (abs(line1In.vector.i * line2In.vector.j - line2In.vector.i * line1In.vector.j) < EPSILON5)
    {
        pointOut = TZPOINT(0, 0, 0);
        if (IsPointIn(line1In.point, line2In))
        {
            return ErrorType::TZ_OVERLAP;
        }
        return ErrorType::TZ_PARALLEL;
    }
    else
    {
        pointOut = TZPOINT(dA3 / dC3, dB3 / dC3, 0);
        return 1;
    }
}

#pragma endregion



DLLOUTAPI bool __stdcall num_stdev(double* dataIn, int dataCnt, double& stdev, double& mean)
{
    vector<double> datas(dataCnt);
    for (int i = 0; i < dataCnt; i++)
    {
        datas[i] = dataIn[i];
    }

    if (datas.size() < 1) { return false; }
    double sum = std::accumulate(std::begin(datas), std::end(datas), 0.0);
    mean = sum / datas.size();
    double accum = 0.0;
    std::for_each(std::begin(datas), std::end(datas), [&](const double dist)
        {
            accum += (dist - mean) * (dist - mean);
        });
    stdev = sqrt(accum / datas.size());
    return true;
}
```

##### c++ 中指针和引用的区别

###### 1.两者的定义和性质不同

指针是一个变量，存储的是一个地址，指向内存的一个存储单元；

引用是原变量的一个别名，跟原来的变量实质上是同一个东西。

###### 2.指针可以有多级，引用只能是一级

```c++
int **p //合法
int &&a; //不合法
```

###### 3.指针可以在定义的时候不初始化，引用必须在定义的时候初始化

###### 4.指针可以指向NULL,引用不可以为NULL

###### 5.指针初始化之后可以再改变，引用不可以

###### 6.sizeof的运算结果不同

```c++
int a = 996;
int *p = &a;
int &r = a;

cout << sizeof(p); // 返回 int* 类型的大小
cout << sizeof(r); // 返回 int 类型的大小
```

###### 7.自增运算意义不同

指针自增之后指向内容后面的内存

引用自增相当于原数据自增

###### 8.指针和引用作为函数参数时，指针需要检查是否为空，应用不需要

##### c++ 中的auto ， const auto&

auto：在块作用域、命名作用域、循环初始化语句等等 中声明变量时，关键词auto用作类型指定符。

const:修饰符

 想要拷贝元素：for(auto x:range)

 想要修改元素 : for(auto &&x:range)

 想要只读元素：for(const auto& x:range)

auto
 auto即 for(auto x:range) 这样会拷贝一份range元素，而不会改变range中元素；

但是！（重点) 使用for(auto x:vector)时得到一个proxy class,操作时会改变vector本身元素。应用：for(bool x:vector)

auto&
 当需要修改range中元素，用for(auto& x:range)

当vector返回临时对象，使用auto&会编译错误，临时对象不能绑在non-const l-value reference （左值引用）需使用auto&&,初始化右值时也可捕获

const auto&
 当只想读取range中元素时，使用const auto&,如：for(const auto&x:range),它不会进行拷贝，也不会修改range

const auto
 当需要拷贝元素，但不可修改拷贝出来的值时，使用 for(const auto x:range)，避免拷贝开销

#### 11.25

##### c++ 关键字protected 的作用详解

###### **三种权限的区别：**

- **public:**可以被任意实体访问
- **protected:**只允许本类**及子类**的成员函数访问
- **private:**只允许本类的成员函数访问

###### 继承的方式有三种：

公共继承
保护继承
私有继承

###### 继承后的属性变化:

使用private继承,基类的所有方法在子类中变为private;
使用protected继承,将基类中public成员变为子类的protected成员，其它成员的访问权限不变；
使用public继承,基类中的方法属性不发生改变;

#### 11.29

##### linux c++ 非阻塞tcp 通信模板（select 模型）

###### client.h 头文件

```c++
#ifndef TCPCLIENTRTA_H
#define TCPCLIENTRTA_H
#pragma once

#ifndef _MSC_VER
#include<stdio.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<string.h>
#include<unistd.h>
#include<errno.h>
#include<iostream>
#define BUFFER_SIZE 1024
using namespace std;
//tcp客户端端的代码
class TcpClientRTA
{
public:
    TcpClientRTA();
    ~TcpClientRTA();
    bool StartServer();
    bool SendMsg(const char* msg);
    bool RevcMsg(char* msg, int size);
    bool CloseServer();
private:
    char recv_msg[BUFFER_SIZE];
    char send_msg[BUFFER_SIZE];//数据收发缓冲区
    int  server_sock_fd;
    fd_set client_fd_set={0};
};
#endif  //_MSC_VER
#endif // RTATCPCLIENT_H
```

###### client.cpp 文件

```c++
#ifndef _MSC_VER
#include"tcpClientRTA.h"

TcpClientRTA::TcpClientRTA()
{
}

TcpClientRTA::~TcpClientRTA()
{

}

bool TcpClientRTA::StartServer()
{
    struct sockaddr_in server_addr;
    memset(&server_addr,0,sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(9999);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    //创建套接字
    if ((server_sock_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);
        return false;
    }
    //连接服务器
    if (connect(server_sock_fd, (struct sockaddr *) &server_addr,sizeof(struct sockaddr_in)) < 0) {
        printf("connect error: %s(errno: %d)\n",strerror(errno),errno);
        return false;
    }
         return true;
}

bool TcpClientRTA::SendMsg(const char* msg)
{
    strncpy(send_msg,msg,BUFFER_SIZE);
    if (send(server_sock_fd, send_msg, BUFFER_SIZE, 0) < 0) {
        printf("send message error: %s(errno:%d)\n",strerror(errno),errno);
        return false;
    }
    return true;
}

bool TcpClientRTA::RevcMsg(char* msg, int size)
{
    if(size>BUFFER_SIZE)
    {
        size=BUFFER_SIZE;
    }
    memset(msg,'\0',size);
    FD_ZERO(&client_fd_set);
    FD_SET(STDIN_FILENO, &client_fd_set);
    FD_SET(server_sock_fd, &client_fd_set);

    select(server_sock_fd + 1, &client_fd_set, NULL, NULL, 0);
    if (FD_ISSET(server_sock_fd, &client_fd_set))
    {
        memset(recv_msg,0, BUFFER_SIZE);
        int n = recv(server_sock_fd, recv_msg, BUFFER_SIZE, 0);
        // recv msg
        if (n > 0)
        {
            printf("recv %d byte\n",n);
            if (n > BUFFER_SIZE)
            {
                n = BUFFER_SIZE;
            }
            recv_msg[n] = '\0';
            memcpy(msg,recv_msg,BUFFER_SIZE);
            printf("Received a message from the server:%s\n", msg);
        }
        else if (n < 0)
        {
            printf("Error receiving message!\n");
            return false;
        }
        else
        {
            printf("connection closed!\n");
            close(server_sock_fd);
            return false;
        }
     }
   return true;
}

bool TcpClientRTA::CloseServer()
{
    close(server_sock_fd);
    return true;
}
#endif
```

###### select 模型

函数原型：

```c++
int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout);
// maxfdp1 整数值，集合中所有文件描述符的范围，所有文件描述符最大值加1
// readset 指向fdset的指针，监视文件描述符的读变化
// writeset 监视集合中文件描述符的写变化，只要有一个文件可写，函数就返回一个大于0的值
// exceptsset 监视集合中的错误异常文件
```

返回值：成功返回做好准备的文件描述符的个数；超时为0；错误为-1.

最后一个参数：timeout：select的超时时间。

​     若以null形式传入，即不传入时间结构，就是将select置于阻塞状态，一直等到监视文件描述符集合中某个文件描述符发生变化为止。

​     若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；
​      timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

I.传递给select函数的参数会告诉内核：

我们所关心的文件描述符
对每个描述符，我们所关心的状态。(是想从一个文件描述符中读或者写，还是关注一个描述符中是否出现异常)
要等待多长时间。(可以等待无限长的时间；等待固定的一段时间；或者根本就不等待)
II.从select函数返回后，内核会告诉我们：

对我们的要求已经做好准备的描述符的个数
对于三种条件(读，写，异常)哪些描述符已经做好准备

#### 11.30

##### c++ bzero 和memset函数

将内存块（字符串）的前n个字节清零

```c++
bzero（void*s，int n） 和 memset（（void*） s，0，size_tn);
```

##### c++ strcpy strncpy memcpy 的区别

###### 1.strcpy

- 从s2中拷贝字符到s1中，遇到'\0'终止('\0'也会拷贝),如果s1的长度不够，则会内存溢出

```c++
char *strcpy(char *s1, const char *s2);
```

###### 2.strncpy

- 说明：从s2中拷贝n个字符到s1中，不会拷贝'\0'之后的字符('\0'不会拷贝)，如果拷贝的长度不足n，自动补充'\0',如果s1的长度小于n，则会内存溢出

```c++
char *strncpy(char *s1, const char *s2, size_t n);
```

###### 3.memcpy

- 说明：从s2中拷贝n个字节的数据到s1中(不受'\0'的影响)，n大于s2的字节长度时，会产生未定义的值

```c++
char *strncpy(char *s1, const char *s2, size_t n);
```

##### c++ 线性插值的理解与实现

###### 代码实现：

```c++
//查找相邻补偿
bool findAdjacentOffset(vector<double> Positions, double currentPos, int& minIndex, int& maxIndex)
{
	double maxPos = DBL_MAX;
	double minPos = DBL_MIN;
	maxIndex = -1;
	minIndex = -1;
	//查找大于当前位置的最小值,小于当前为位置的最大值
	for (int i = 0; i < Positions.size(); i++)
	{
		if (Positions[i] > currentPos)
		{
			if (maxPos >= Positions[i])
			{
				maxPos = Positions[i];
				maxIndex = i;
			}
		}
		else
		{
			if (minPos <= Positions[i])
			{
				minPos = Positions[i];
				minIndex = i;
			}
		}
	}

	if (minIndex < 0)
	{
		minIndex = maxIndex;
	}
	else if (maxIndex < 0)
	{
		maxIndex = minIndex;
	}
	return true;
}
// 线性差值
bool Interpolate(vector<FloatOffset> Offsets, vector<double> PositionX, RtaInterpolationParam param, RtaResult& results)
{
	double step = (param.swathEnd.x - param.swathStart.x) / ((double)param.offsetMapLength - 1);
	results.offsets.clear();
	for (int i = 0; i < param.offsetMapLength; i++)
	{
		double currentPos = param.swathStart.x + i * step;
		int minIndex, maxIndex;

		//查找当前位置的相邻补偿
		findAdjacentOffset(PositionX, currentPos, minIndex, maxIndex);
		double dist = abs(PositionX[maxIndex] - PositionX[minIndex]);

		//线性插值
		if (dist < EPSILON6)
		{
			results.offsets.push_back(Offsets[minIndex]);
		}
		else
		{
			double distAB = abs(currentPos - PositionX[minIndex]);
			double distBC = abs(currentPos - PositionX[maxIndex]);
			double distFactor = 1.0 / dist;

			FloatOffset offset;
			offset.x = (distAB * Offsets[maxIndex].x + distBC * Offsets[minIndex].x) * distFactor;
			offset.y = (distAB * Offsets[maxIndex].y + distBC * Offsets[minIndex].y) * distFactor;
			results.offsets.push_back(offset);
		}
	}

	return true;
}
```

###### 理解：

线性差值的应用场景为确认直线上两点之间的具体数值，如已知ac两点对应的数值，b在ac之间。可根据(var- a)/ab = (c-var)/bc确认未知量var的值。

双线性差值是在线性差值的基础上再平面上确认点的具体数值，需要在x方向做两次线性插值确认y方向线性插值范围，再在y方向做一次线性插值，确认点在平面上的具体数值。